* 構造

  application
  + room_message
  + header
  + lobby
  + matching (include matching_interval)
  + battle
  + result
  + builder (かなり疎結合)

  ・support_child はすべてに mixin
  ・builder だけは完全分離で他は分離できないので基本indexにすべてのメソッドがある
  ・ライブラリではないので $parent をむしろ積極的に使っていく

* 重要

  ・Vuex を使うな
  ・どうしてもグローバル変数にしないといけなくなったときでも Vuex を使うな
  ・死んでも Vuex を使うな

* rule_key
  |--------------+--------------+------------------------------------------------|
  | sy_marathon  | マラソン     | マイペースに先にゴールした方が勝ち             |
  | sy_singleton | シングルトン | 一人しか答える権利がない早押しクイズ形式       |
  | sy_hybrid    | ハイブリッド | 同時進行だけど一方が答えると両方次の問題に進む |
  |--------------+--------------+------------------------------------------------|

* sub_mode
  |-------------+------------------------|
  | sm1_standby | 最初                   |
  | sm2_readygo | 開始前の待ち時間       |
  | sm3_deden   | 問題番号表示           |
  | sm4_tactic  | ユーザー考え中・操作中 |
  | sm5_correct | 正解「○」表示中       |
  | sm6_timeout | 時間切れ表示中         |
  |-------------+------------------------|

* sub_mode が sm4_tactic のときの x_mode (sy_singleton 専用)
  |----------+--------------------------------|
  | x1_think | 両者が問題を見て考えている     |
  | x2_play  | わかったので自分だけが操作中   |
  | x3_see   | 自分以外は相手の操作を見ている |
  |----------+--------------------------------|

* チャンネル
  |--------+--------------------------------+----------------------+-----------|
  | name   |                                | 接続                 | スコープ  |
  |--------+--------------------------------+----------------------+-----------|
  | School | 接続中の人数などを配信する     | 常時                 | 全体      |
  | Lobby  | マッチングしたら部屋を配信する | ロビーとマッチング中 | 全体      |
  | Room   | 対戦するための部屋             | 対戦中のみ常時       | room_id   |
  | Battle | 対戦時                         | バトル毎に作り直す   | battle_id |
  |--------+--------------------------------+----------------------+-----------|

* 対戦までの流れ

  |--------+--------------------+--------------------------------+---------------+--------------+----------------|
  | 配信元 |                    |                                |               | 購読中       |                |
  |--------+--------------------+--------------------------------+---------------+--------------+----------------|
  |        | matching_search    | マッチング中                   |               |              |                |
  | Lobby  | room_broadcasted   | 成立したので部屋を配信         |               | Lobby        |                |
  |        | -> room_setup      | 部屋(ID)で購読する             | Lobby購読停止 | Room         | チャット初期化 |
  | Room   | battle_broadcasted | するとバトル(ID)が送られてくる |               | Room,        |                |
  |        | -> battle_setup    | そのバトル(ID)でバトルを購読   |               | Room, Battle |                |
  |--------+--------------------+--------------------------------+---------------+--------------+----------------|

* 変数

  |-------------------+----------------+--------------------------------|
  | name              |                |                                |
  |-------------------+----------------+--------------------------------|
  | current_questtion | 今出題中の問題 | この用途以外に使ってはいけない |
  |-------------------+----------------+--------------------------------|

* シングルトン・動作フロー

  |----------------+-------------|
  | A              | 送信        |
  |----------------+-------------|
  | answer_button_push_handle | question_id |
  |----------------+-------------|

* 排他制御について

  PCとスマホの両方でロビーを表示した状態でスマホで対戦を開始する
  このときPCでもブロードキャストに反応してしまい二重で対局が開始する
  そうなると問題が一気に2つ進むなど不可解なことが起こる
  そこで楽観的ロックを使う
  (スマホ側で)
  ロビーに来たときランダムな値を入れた session_lock_token を持っておく
  これは Rails 側から渡しているけど JavaScript 側で作成してもよい
  そして STARTした瞬間に session_lock_token を PUT で current_user.actb_setting.session_lock_token に書き込む
  (PC側で)
  マッチングを開始しているときはJS側で持っている session_lock_token と current_user.actb_setting.session_lock_token が異なるので、
  あらゆることを無効とする

  これ最初はロビーを表示するときに current_user.actb_setting.session_lock_token に書き込むようにしていたけど、
  ロビーを GET した直後に HTMLバリデータプラグインなどがまた GET するので、常に session_lock_token が古くなってしまう
  これじゃ開発ができない
  ので、START のタイミングとした

* BOTとの対戦中に通知が来て対人戦が始められる仕組み

  - BOTとの対戦中はロビーとの接続を維持する
  - 通知があったとき Lobby が有効なら confirm を出して OK なら new_challenge_accept_handle を呼ぶ

  |--------+-------+------+--------+---------------------------------------------------------|
  |        | Lobby | Room | Battle |                                                         |
  |--------+-------+------+--------+---------------------------------------------------------|
  | ロビー | ○    |      |        |                                                         |
  | 対戦中 | ○    | ○   | ○     | Lobbyを接続しっぱななしなので通知を受けとることができる |
  |--------+-------+------+--------+---------------------------------------------------------|

* 問題

  開発環境をiPhoneで見たときドメインが異なるため配信されない
  そのためデバッグモードで結果画面に行けない
  ただ単に行けるようにはできるが、そうするとPCで見たとき再戦ができなくなる

* TODO

  Nuxt.js 移行
